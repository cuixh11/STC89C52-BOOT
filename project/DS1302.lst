C51 COMPILER V9.02   DS1302                                                                04/12/2022 17:34:17 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE DS1302
OBJECT MODULE PLACED IN ..\output\DS1302.obj
COMPILER INVOKED BY: D:\Keil_v4\C51\BIN\C51.EXE ..\src\DS1302.c BROWSE INCDIR(..\inc) DEBUG OBJECTEXTEND PRINT(.\DS1302.
                    -lst) OBJECT(..\output\DS1302.obj)

line level    source

   1          /*********************************************************************************** 
   2          ;功能说明:STC89C52开机次数+数码管温度报警+1602时间
   3          ;文件名称:DS1302.c
   4          :描    述：实时时钟芯片DS1302驱动模块
   5          ;版本号：v1.0.0  
   6          ;微处理器:STC89C52
   7          ;编译环境:Keil uVision V4.10 
   8          ;作    者:Cui Xinghai 
   9          ;创建日期:2022.4.9   
  10          ;***********************************************************************************/
  11          
  12          #define  _DS1302_C
  13          #include "config.h"
  14          #include "DS1302.h"
  15          
  16          /* 发送一个字节到DS1302通信总线上 */
  17          void DS1302ByteWrite(uint8 dat)
  18          {
  19   1          uint8 mask;
  20   1          
  21   1          for (mask=0x01; mask!=0; mask<<=1)  //低位在前，逐位移出
  22   1          {
  23   2              if ((mask&dat) != 0) //首先输出该位数据
  24   2                  DS1302_IO = 1;
  25   2              else
  26   2                  DS1302_IO = 0;
  27   2              DS1302_CK = 1;       //然后拉高时钟
  28   2              DS1302_CK = 0;       //再拉低时钟，完成一个位的操作
  29   2          }
  30   1          DS1302_IO = 1;           //最后确保释放IO引脚
  31   1      }
  32          /* 由DS1302通信总线上读取一个字节 */
  33          uint8 DS1302ByteRead()
  34          {
  35   1          uint8 mask;
  36   1          uint8 dat = 0;
  37   1          
  38   1          for (mask=0x01; mask!=0; mask<<=1)  //低位在前，逐位读取
  39   1          {
  40   2              if (DS1302_IO != 0)  //首先读取此时的IO引脚，并设置dat中的对应位
  41   2              {
  42   3                  dat |= mask;
  43   3              }
  44   2              DS1302_CK = 1;       //然后拉高时钟
  45   2              DS1302_CK = 0;       //再拉低时钟，完成一个位的操作
  46   2          }
  47   1          return dat;              //最后返回读到的字节数据
  48   1      }
  49          /* 用单次写操作向某一寄存器写入一个字节，reg-寄存器地址，dat-待写入字节 */
  50          void DS1302SingleWrite(uint8 reg, uint8 dat)
  51          {
  52   1          DS1302_CE = 1;                   //使能片选信号
  53   1          DS1302ByteWrite((reg<<1)|0x80);  //发送写寄存器指令
  54   1          DS1302ByteWrite(dat);            //写入字节数据
C51 COMPILER V9.02   DS1302                                                                04/12/2022 17:34:17 PAGE 2   

  55   1          DS1302_CE = 0;                   //除能片选信号
  56   1      }
  57          /* 用单次读操作从某一寄存器读取一个字节，reg-寄存器地址，返回值-读到的字节 */
  58          uint8 DS1302SingleRead(uint8 reg)
  59          {
  60   1          uint8 dat;
  61   1          
  62   1          DS1302_CE = 1;                   //使能片选信号
  63   1          DS1302ByteWrite((reg<<1)|0x81);  //发送读寄存器指令
  64   1          dat = DS1302ByteRead();          //读取字节数据
  65   1          DS1302_CE = 0;                   //除能片选信号
  66   1          
  67   1          return dat;
  68   1      }
  69          /* 用突发模式连续写入8个寄存器数据，dat-待写入数据指针 */
  70          void DS1302BurstWrite(uint8 *dat)
  71          {
  72   1          uint8 i;
  73   1          
  74   1          DS1302_CE = 1;
  75   1          DS1302ByteWrite(0xBE);  //发送突发写寄存器指令
  76   1          for (i=0; i<8; i++)     //连续写入8字节数据
  77   1          {
  78   2              DS1302ByteWrite(dat[i]);
  79   2          }
  80   1          DS1302_CE = 0;
  81   1      }
  82          /* 用突发模式连续读取8个寄存器的数据，dat-读取数据的接收指针 */
  83          void DS1302BurstRead(uint8 *dat)
  84          {
  85   1          uint8 i;
  86   1          
  87   1          DS1302_CE = 1;
  88   1          DS1302ByteWrite(0xBF);  //发送突发读寄存器指令
  89   1          for (i=0; i<8; i++)     //连续读取8个字节
  90   1          {
  91   2              dat[i] = DS1302ByteRead();
  92   2          }
  93   1          DS1302_CE = 0;
  94   1      }
  95          /* 获取实时时间，即读取DS1302当前时间并转换为时间结构体格式 */
  96          void GetRealTime(struct sTime *time)
  97          {
  98   1          uint8 buf[8];
  99   1          
 100   1          DS1302BurstRead(buf);
 101   1          time->year = buf[6] + 0x2000;
 102   1          time->mon  = buf[4];
 103   1          time->day  = buf[3];
 104   1          time->hour = buf[2];
 105   1          time->min  = buf[1];
 106   1          time->sec  = buf[0];
 107   1          time->week = buf[5];
 108   1      }
 109          /* 设定实时时间，时间结构体格式的设定时间转换为数组并写入DS1302 */
 110          void SetRealTime(struct sTime *time)
 111          {
 112   1          uint8 buf[8];
 113   1          
 114   1          buf[7] = 0;
 115   1          buf[6] = time->year;
 116   1          buf[5] = time->week;
C51 COMPILER V9.02   DS1302                                                                04/12/2022 17:34:17 PAGE 3   

 117   1          buf[4] = time->mon;
 118   1          buf[3] = time->day;
 119   1          buf[2] = time->hour;
 120   1          buf[1] = time->min;
 121   1          buf[0] = time->sec;
 122   1          DS1302BurstWrite(buf);
 123   1      }
 124          /* DS1302初始化，如发生掉电则重新设置初始时间 */
 125          void InitDS1302()
 126          {
 127   1          uint8 dat;
 128   1          struct sTime code InitTime[] = {  //默认初始值：2014-01-01 12:30:00 星期3
 129   1              0x2014,0x01,0x01, 0x12,0x30,0x00, 0x03
 130   1          };
 131   1          
 132   1          DS1302_CE = 0;  //初始化DS1302通信引脚
 133   1          DS1302_CK = 0;
 134   1          dat = DS1302SingleRead(0);  //读取秒寄存器
 135   1          if ((dat & 0x80) != 0)      //由秒寄存器最高位CH的值判断DS1302是否已停止
 136   1          {
 137   2              DS1302SingleWrite(7, 0x00);  //撤销写保护以允许写入数据
 138   2              SetRealTime(&InitTime);      //设置DS1302为默认的初始时间
 139   2          }
 140   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    348    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      25
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
