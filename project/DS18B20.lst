C51 COMPILER V9.02   DS18B20                                                               04/12/2022 17:34:17 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE DS18B20
OBJECT MODULE PLACED IN ..\output\DS18B20.obj
COMPILER INVOKED BY: D:\Keil_v4\C51\BIN\C51.EXE ..\src\DS18B20.c BROWSE INCDIR(..\inc) DEBUG OBJECTEXTEND PRINT(.\DS18B2
                    -0.lst) OBJECT(..\output\DS18B20.obj)

line level    source

   1          /*********************************************************************************** 
   2          ;功能说明:STC89C52开机次数+数码管温度报警+1602时间
   3          ;文件名称:DS18B20.c
   4          :描    述：温度传感器DS18B20驱动模块
   5          ;版本号：v1.0.0  
   6          ;微处理器:STC89C52
   7          ;编译环境:Keil uVision V4.10 
   8          ;作    者:Cui Xinghai 
   9          ;创建日期:2022.4.9   
  10          ;***********************************************************************************/
  11          
  12          #define  _DS18B20_C
  13          #include "config.h"
  14          #include "DS18B20.h"
  15          
  16          /* 软件延时函数，延时时间(t*10)us */
  17          void DelayX10us(uint8 t)
  18          {
  19   1          do {
  20   2              _nop_();
  21   2              _nop_();
  22   2              _nop_();
  23   2              _nop_();
  24   2              _nop_();
  25   2              _nop_();
  26   2              _nop_();
  27   2              _nop_();
  28   2          } while (--t);
  29   1      }
  30          /* 复位总线，获取存在脉冲，以启动一次读写操作 */
  31          bit Get18B20Ack()
  32          {
  33   1          bit ack;
  34   1          
  35   1          EA = 0;   //禁止总中断
  36   1          IO_18B20 = 0;     //产生500us复位脉冲
  37   1          DelayX10us(50);
  38   1          IO_18B20 = 1;
  39   1          DelayX10us(6);    //延时60us
  40   1          ack = IO_18B20;   //读取存在脉冲
  41   1          while(!IO_18B20); //等待存在脉冲结束
  42   1          EA = 1;   //重新使能总中断
  43   1          
  44   1          return ack;
  45   1      }
  46          /* 向DS18B20写入一个字节，dat-待写入字节 */
  47          void Write18B20(uint8 dat)
  48          {
  49   1          uint8 mask;
  50   1          
  51   1          EA = 0;   //禁止总中断
  52   1          for (mask=0x01; mask!=0; mask<<=1)  //低位在先，依次移出8个bit
  53   1          {
  54   2              IO_18B20 = 0;         //产生2us低电平脉冲
C51 COMPILER V9.02   DS18B20                                                               04/12/2022 17:34:17 PAGE 2   

  55   2              _nop_();
  56   2              _nop_();
  57   2              if ((mask&dat) == 0)  //输出该bit值
  58   2                  IO_18B20 = 0;
  59   2              else
  60   2                  IO_18B20 = 1;
  61   2              DelayX10us(6);        //延时60us
  62   2              IO_18B20 = 1;         //拉高通信引脚
  63   2          }
  64   1          EA = 1;   //重新使能总中断
  65   1      }
  66          /* 从DS18B20读取一个字节，返回值-读到的字节 */
  67          uint8 Read18B20()
  68          {
  69   1          uint8 dat;
  70   1          uint8 mask;
  71   1          
  72   1          EA = 0;   //禁止总中断
  73   1          for (mask=0x01; mask!=0; mask<<=1)  //低位在先，依次采集8个bit
  74   1          {
  75   2              IO_18B20 = 0;         //产生2us低电平脉冲
  76   2              _nop_();
  77   2              _nop_();
  78   2              IO_18B20 = 1;         //结束低电平脉冲，等待18B20输出数据
  79   2              _nop_();              //延时2us
  80   2              _nop_();
  81   2              if (!IO_18B20)        //读取通信引脚上的值
  82   2                  dat &= ~mask;
  83   2              else
  84   2                  dat |= mask;
  85   2              DelayX10us(6);        //再延时60us
  86   2          }
  87   1          EA = 1;   //重新使能总中断
  88   1      
  89   1          return dat;
  90   1      }
  91          /* 启动一次18B20温度转换，返回值-表示是否启动成功 */
  92          bit Start18B20()
  93          {
  94   1          bit ack;
  95   1          
  96   1          ack = Get18B20Ack();   //执行总线复位，并获取18B20应答
  97   1          if (ack == 0)          //如18B20正确应答，则启动一次转换
  98   1          {
  99   2              Write18B20(0xCC);  //跳过ROM操作
 100   2              Write18B20(0x44);  //启动一次温度转换
 101   2          }
 102   1          return ~ack;   //ack==0表示操作成功，所以返回值对其取反
 103   1      }
 104          /* 读取DS18B20转换的温度值，返回值-表示是否读取成功 */
 105          bit Get18B20Temp(int16 *temp)
 106          {
 107   1          bit ack;
 108   1          uint8 LSB, MSB; //16bit温度值的低字节和高字节
 109   1          
 110   1          ack = Get18B20Ack();    //执行总线复位，并获取18B20应答
 111   1          if (ack == 0)           //如18B20正确应答，则读取温度值
 112   1          {
 113   2              Write18B20(0xCC);   //跳过ROM操作
 114   2              Write18B20(0xBE);   //发送读命令
 115   2              LSB = Read18B20();  //读温度值的低字节
 116   2              MSB = Read18B20();  //读温度值的高字节
C51 COMPILER V9.02   DS18B20                                                               04/12/2022 17:34:17 PAGE 3   

 117   2              *temp = ((int16)MSB << 8) + LSB;  //合成为16bit整型数
 118   2          }
 119   1              return ~ack;  //ack==0表示操作应答，所以返回值为其取反值
 120   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    187    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
