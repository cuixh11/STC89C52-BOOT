C51 COMPILER V9.02   I2C                                                                   04/12/2022 17:34:17 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN ..\output\I2C.obj
COMPILER INVOKED BY: D:\Keil_v4\C51\BIN\C51.EXE ..\src\I2C.c BROWSE INCDIR(..\inc) DEBUG OBJECTEXTEND PRINT(.\I2C.lst) O
                    -BJECT(..\output\I2C.obj)

line level    source

   1          /*********************************************************************************** 
   2          ;功能说明:STC89C52开机次数+数码管温度报警+1602时间
   3          ;文件名称:I2C.c
   4          :描    述：I2C总线驱动模块      * 备注：基于IO口模拟实现，总线时序延时等皆由软件方式实现
   5          ;版本号：v1.0.0  
   6          ;微处理器:STC89C52
   7          ;编译环境:Keil uVision V4.10 
   8          ;作    者:Cui Xinghai 
   9          ;创建日期:2022.4.9   
  10          ;***********************************************************************************/
  11          
  12          #define  _I2C_C
  13          #include "config.h"
  14          #include "I2C.h"
  15          
  16          #define I2CDelay()  {_nop_();_nop_();_nop_();_nop_();}
  17          
  18          /* 产生总线起始信号 */
  19          void I2CStart()
  20          {
  21   1          I2C_SDA = 1; //首先确保SDA、SCL都是高电平
  22   1          I2C_SCL = 1;
  23   1          I2CDelay();
  24   1          I2C_SDA = 0; //先拉低SDA
  25   1          I2CDelay();
  26   1          I2C_SCL = 0; //再拉低SCL
  27   1      }
  28          /* 产生总线停止信号 */
  29          void I2CStop()
  30          {
  31   1          I2C_SCL = 0; //首先确保SDA、SCL都是低电平
  32   1          I2C_SDA = 0;
  33   1          I2CDelay();
  34   1          I2C_SCL = 1; //先拉高SCL
  35   1          I2CDelay();
  36   1          I2C_SDA = 1; //再拉高SDA
  37   1          I2CDelay();
  38   1      }
  39          /* I2C总线写操作，dat-待写入字节，返回值-从机应答位的值 */
  40          bit I2CWrite(uint8 dat)
  41          {
  42   1          bit ack;  //用于暂存应答位的值
  43   1          uint8 mask;  //用于探测字节内某一位值的掩码变量
  44   1      
  45   1          for (mask=0x80; mask!=0; mask>>=1) //从高位到低位依次进行
  46   1          {
  47   2              if ((mask&dat) == 0)  //该位的值输出到SDA上
  48   2                  I2C_SDA = 0;
  49   2              else
  50   2                  I2C_SDA = 1;
  51   2              I2CDelay();
  52   2              I2C_SCL = 1;          //拉高SCL
  53   2              I2CDelay();
  54   2              I2C_SCL = 0;          //再拉低SCL，完成一个位周期
C51 COMPILER V9.02   I2C                                                                   04/12/2022 17:34:17 PAGE 2   

  55   2          }
  56   1          I2C_SDA = 1;   //8位数据发送完后，主机释放SDA，以检测从机应答
  57   1          I2CDelay();
  58   1          I2C_SCL = 1;   //拉高SCL
  59   1          ack = I2C_SDA; //读取此时的SDA值，即为从机的应答值
  60   1          I2CDelay();
  61   1          I2C_SCL = 0;   //再拉低SCL完成应答位，并保持住总线
  62   1      
  63   1          return (~ack); //应答值取反以符合通常的逻辑：
  64   1                         //0=不存在或忙或写入失败，1=存在且空闲或写入成功
  65   1      }
  66          /* I2C总线读操作，并发送非应答信号，返回值-读到的字节 */
  67          uint8 I2CReadNAK()
  68          {
  69   1          uint8 mask;
  70   1          uint8 dat;
  71   1      
  72   1          I2C_SDA = 1;  //首先确保主机释放SDA
  73   1          for (mask=0x80; mask!=0; mask>>=1) //从高位到低位依次进行
  74   1          {
  75   2              I2CDelay();
  76   2              I2C_SCL = 1;      //拉高SCL
  77   2              if(I2C_SDA == 0)  //读取SDA的值
  78   2                  dat &= ~mask; //为0时，dat中对应位清零
  79   2              else
  80   2                  dat |= mask;  //为1时，dat中对应位置1
  81   2              I2CDelay();
  82   2              I2C_SCL = 0;      //再拉低SCL，以使从机发送出下一位
  83   2          }
  84   1          I2C_SDA = 1;   //8位数据发送完后，拉高SDA，发送非应答信号
  85   1          I2CDelay();
  86   1          I2C_SCL = 1;   //拉高SCL
  87   1          I2CDelay();
  88   1          I2C_SCL = 0;   //再拉低SCL完成非应答位，并保持住总线
  89   1      
  90   1          return dat;
  91   1      }
  92          /* I2C总线读操作，并发送应答信号，返回值-读到的字节 */
  93          uint8 I2CReadACK()
  94          {
  95   1          uint8 mask;
  96   1          uint8 dat;
  97   1      
  98   1          I2C_SDA = 1;  //首先确保主机释放SDA
  99   1          for (mask=0x80; mask!=0; mask>>=1) //从高位到低位依次进行
 100   1          {
 101   2              I2CDelay();
 102   2              I2C_SCL = 1;      //拉高SCL
 103   2              if(I2C_SDA == 0)  //读取SDA的值
 104   2                  dat &= ~mask; //为0时，dat中对应位清零
 105   2              else
 106   2                  dat |= mask;  //为1时，dat中对应位置1
 107   2              I2CDelay();
 108   2              I2C_SCL = 0;      //再拉低SCL，以使从机发送出下一位
 109   2          }
 110   1          I2C_SDA = 0;   //8位数据发送完后，拉低SDA，发送应答信号
 111   1          I2CDelay();
 112   1          I2C_SCL = 1;   //拉高SCL
 113   1          I2CDelay();
 114   1          I2C_SCL = 0;   //再拉低SCL完成应答位，并保持住总线
 115   1      
 116   1          return dat;
C51 COMPILER V9.02   I2C                                                                   04/12/2022 17:34:17 PAGE 3   

 117   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    194    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
