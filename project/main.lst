C51 COMPILER V9.02   MAIN                                                                  04/12/2022 17:34:17 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\output\main.obj
COMPILER INVOKED BY: D:\Keil_v4\C51\BIN\C51.EXE ..\src\main.c BROWSE INCDIR(..\inc) DEBUG OBJECTEXTEND PRINT(.\main.lst)
                    - OBJECT(..\output\main.obj)

line level    source

   1          /*********************************************************************************** 
   2          ;功能说明:STC89C52开机次数+数码管温度报警+1602时间
   3          ;文件名称:main.c     
   4          ;版本号：v1.0.0  
   5          ;微处理器:STC89C52
   6          ;编译环境:Keil uVision V4.10 
   7          ;作    者:Cui Xinghai 
   8          ;创建日期:2022.4.9   
   9          ;***********************************************************************************/
  10          
  11          #define  _MAIN_C
  12          #include <REG52.H>
  13          
  14          #include "config.h"
  15          #include "LCD1602.h"
  16          #include "LedBuzzer.h"
  17          #include "I2C.h"
  18          #include "eeprom.h"
  19          #include "keyboard.h"
  20          #include "DS18B20.h"
  21          #include "DS1302.h"
  22          #include "main.h"
  23          
  24          #include <reg52.h>
  25          
  26          bit     flag100ms        = 0;    //100ms定时标志
  27          uint8   T0RH             = 0;    //T0重载值的高字节
  28          uint8   T0RL             = 0;    //T0重载值的低字节
  29          int     tempalarm        = 26;   //温度蜂鸣器报警初始值
  30          uint8   dat;
  31          
  32          extern struct sLedBuff ledBuff; //LED显示缓冲区，默认初值全0，正好达到上电全亮的效果
  33          extern unsigned char code LedChar[]; //数码管显示字符转换表
  34          
  35          void main()
  36          {
  37   1               uint8 tmr1s = 10;
  38   1               uint8 delay = 1;
  39   1      
  40   1          EA = 1;       //使能总中断
  41   1              ConfigTimer0(1);  //配置T0定时1ms
  42   1          ENLED = 0;    //使能U3，选择控制数码管
  43   1          ADDR3 = 1;    //因为需要动态改变ADDR0-2的值，所以不需要再初始化了
  44   1      
  45   1              dat =E2ReadByte(0x02);    //读取指定地址上的一个字节
  46   1              LedNumber();
  47   1              if (dat>98) dat =0;
  48   1              else ++dat;
  49   1              E2WriteByte(0x02, dat);    //再写回到对应的地址上
  50   1              
  51   1          InitLcd1602();    //初始化液晶模块
  52   1              Start18B20();     //启动首次温度转换
  53   1              BuzzBeep();       //蜂鸣器提示
  54   1      
C51 COMPILER V9.02   MAIN                                                                  04/12/2022 17:34:17 PAGE 2   

  55   1          while (1)
  56   1              {
  57   2                      KeyDriver();      //执行按键驱动
  58   2                      if (flag100ms)    //每隔100ms执行以下分支
  59   2              {
  60   3                  flag100ms = 0;
  61   3                              if (delay > 0)
  62   3                  {
  63   4                      delay--;
  64   4                      if (delay == 0)
  65   4                      {   //本段代码仅在上电延时后执行一次
  66   5                          InitDS1302();  //初始化实时时钟模块
  67   5                      }
  68   4                      continue;
  69   4                  }
  70   3                  ShowRealTime();  //时间显示刷新
  71   3                  tmr1s++;         //每隔1s执行以下分支                               
  72   3                              if (tmr1s >= 10)
  73   3                              {
  74   4                                      tmr1s = 0;
  75   4                                      RefreshTemp();   //温度刷新显示                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
  76   4                              }       
  77   3                      }
  78   2              }
  79   1      }
  80          /* 开机次数数码管显示 */
  81          void LedNumber()
  82          {                       
  83   1          //以下代码将sec按十进制位从低到高依次提取并转为数码管显示字符
  84   1          ledBuff.number[3] = LedChar[16];
  85   1          ledBuff.number[4] = LedChar[dat%10];
  86   1          ledBuff.number[5] = LedChar[dat/10%10];
  87   1      }
  88          /* 温度刷新函数，读取当前温度并根据需要刷新液晶显示 */
  89          void RefreshTemp()
  90          {
  91   1          int16 temp;
  92   1          int intT, decT;  //温度值的整数和小数部分
  93   1      
  94   1          static int16 backup = 32767;  //保证首次执行时必定刷新
  95   1          
  96   1          Get18B20Temp(&temp); //获取当前温度值
  97   1          Start18B20();        //启动下一次转换
  98   1      
  99   1          intT = temp >> 4;             //分离出温度值整数部分
 100   1          decT = temp & 0xF;            //0x0000 0000 0000 1111分离出温度值小数部分
 101   1          temp_alarm(&intT);
*** WARNING C182 IN LINE 101 OF ..\SRC\MAIN.C: pointer to different objects
 102   1      
 103   1              if (backup != temp)  //温度变化时刷新液晶显示
 104   1          {
 105   2              ledBuff.number[2] = LedChar[intT/10] ;  //十位转为ASCII码
 106   2              ledBuff.number[1] = LedChar[intT%10] & 0x7f ;  //个位转为ASCII码
 107   2              ledBuff.number[0] = LedChar[(decT*10) / 16];             
 108   2              backup = temp;             //刷新上次温度值
 109   2              }
 110   1      }
 111          /*温度蜂鸣器报警指示*/
 112          void temp_alarm( int *TEMP) 
 113          {  
*** WARNING C235 IN LINE 113 OF ..\SRC\MAIN.C: parameter 1: different types
 114   1                if(*TEMP >= tempalarm)
C51 COMPILER V9.02   MAIN                                                                  04/12/2022 17:34:17 PAGE 3   

 115   1                {
 116   2                  BuzzBeep();
 117   2                }
 118   1                else 
 119   1                {
 120   2                  BUZZER = 1;        //蜂鸣器静音
 121   2                }
 122   1      }                  
 123          /* 将一个字节按十六进制格式显示到屏幕上，(x,y)-屏幕起始坐标，byt-待显示字节 */
 124          void ShowHexByte(uint8 x, uint8 y, uint8 byt)
 125          {
 126   1          uint8 tmp;
 127   1          uint8 str[4];
 128   1          
 129   1          //高四位转为十六进制字符
 130   1          tmp = byt >> 4;
 131   1          if (tmp <= 9)
 132   1              str[0] = tmp + '0';
 133   1          else
 134   1              str[0] = tmp - 10 + 'A';
 135   1          //低四位转为十六进制字符
 136   1          tmp = byt & 0x0F;
 137   1          if (tmp <= 9)
 138   1              str[1] = tmp + '0';
 139   1          else
 140   1              str[1] = tmp - 10 + 'A';
 141   1          //添加结束符并显示到液晶
 142   1          str[2] = '\0';
 143   1          LcdShowStr(x, y, str);
 144   1      }
 145          /* 读取DS1302时间，显示在液晶屏上 */
 146          void ShowRealTime()
 147          {
 148   1          struct sTime buf;
 149   1          static struct sTime pdata bkp = {0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA};
 150   1      
 151   1          GetRealTime(&buf);
 152   1              if (bkp.year != buf.year)  //年变化时刷新显示
 153   1          {
 154   2              ShowHexByte(1, 0, buf.year);
 155   2              bkp.year = buf.year;
 156   2          }
 157   1              if (bkp.mon != buf.mon)  //月变化时刷新显示
 158   1          {
 159   2              ShowHexByte(0, 1, buf.mon);
 160   2              bkp.mon = buf.mon;
 161   2          }
 162   1              if (bkp.day != buf.day)  //月变化时刷新显示
 163   1          {
 164   2              ShowHexByte(3, 1, buf.day);
 165   2              bkp.day = buf.day;
 166   2          }
 167   1          if (bkp.hour != buf.hour)  //小时变化时刷新显示
 168   1          {
 169   2              ShowHexByte(6, 1, buf.hour);
 170   2              bkp.hour = buf.hour;
 171   2          }
 172   1          if (bkp.min != buf.min)  //分钟变化时刷新显示
 173   1          {
 174   2              ShowHexByte(9, 1, buf.min);
 175   2              bkp.min = buf.min;
 176   2          }
C51 COMPILER V9.02   MAIN                                                                  04/12/2022 17:34:17 PAGE 4   

 177   1          if (bkp.sec != buf.sec)  //秒变化时刷新显示
 178   1          {
 179   2              ShowHexByte(12, 1, buf.sec);
 180   2              bkp.sec = buf.sec;
 181   2          }
 182   1      }
 183          /* 配置并启动T0，ms-T0定时时间 */
 184          void ConfigTimer0(uint16 ms)
 185          {
 186   1          uint32 tmp;
 187   1          
 188   1          tmp = (SYS_MCLK*ms)/1000; //计算所需的计数值
 189   1          tmp = 65536 - tmp;        //计算定时器重载值
 190   1          tmp = tmp + 33;           //补偿中断响应延时造成的误差   
 191   1          T0RH = (uint8)(tmp>>8);   //定时器重载值拆分为高低字节
 192   1          T0RL = (uint8)tmp;
 193   1          TMOD &= 0xF0;   //清零T0的控制位
 194   1          TMOD |= 0x01;   //配置T0为模式1
 195   1          TH0 = T0RH;     //加载T0重载值
 196   1          TL0 = T0RL;
 197   1          ET0 = 1;        //使能T0中断
 198   1          TR0 = 1;        //启动T0
 199   1      }
 200          /* T0中断服务函数，实现系统定时和按键扫描 */
 201          void InterruptTimer0() interrupt 1
 202          {
 203   1          static uint8 tmr100ms = 0;
 204   1          
 205   1          TH0 = T0RH;  //重新加载重载值
 206   1          TL0 = T0RL;
 207   1      
 208   1          BuzzCtrl();  //蜂鸣器发声控制
 209   1          LedScan();   //执行LED扫描
 210   1      //    KeyScan();   //执行按键扫描
 211   1      
 212   1          tmr100ms++;  //定时100ms
 213   1          if (tmr100ms >= 100)
 214   1          {
 215   2              tmr100ms = 0;
 216   2              flag100ms = 1;
 217   2          }
 218   1      }
 219          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    699    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      8    ----
   DATA SIZE        =      8      24
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
